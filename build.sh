#!/bin/bash
set -e

BUILDDIR=.build
ROMFILE_IN=../mk64.rom
ROMFILE_OUT=patched.rom
SYMFILE_IN=./include/mk64/mk64-us.sym
SYMFILE_OUT=$BUILDDIR/symbols.sym
TOOLS=./include/n64/tools/
ELF_OUT=$BUILDDIR/$1.elf

function make_memory_ld {
    # create memory.ld for given RAM and ROM addresses
    echo "/* Auto generated by build.sh */" > $BUILDDIR/memory.ld
    echo "PATCH_ROM_ADDR = $1;" >> $BUILDDIR/memory.ld
    echo "PATCH_RAM_ADDR = $2;" >> $BUILDDIR/memory.ld

    # also create memory.s
    echo "# Auto generated by build.sh" > $BUILDDIR/memory.s
    echo ".equ ROM_BASE, $1" >> $BUILDDIR/memory.s
    echo ".equ RAM_BASE, $2" >> $BUILDDIR/memory.s
}

# create working directory and files
mkdir -p $BUILDDIR
cp -n $SYMFILE_IN $SYMFILE_OUT
cp -n $ROMFILE_IN $ROMFILE_OUT

# create default memory.ld if needed
if [ ! -f $BUILDDIR/memory.ld ]; then
    make_memory_ld 0xC00000 0x80400000
fi

# extract .text offset from memory.ld
TEXT=$(grep 'PATCH_RAM_ADDR' .build/memory.ld | cut -c18-27)
#echo " * TEXT = $TEXT"

# read patch.cfg
unset ENTRY
ROMSIZE=16M
if [ -f $1/patch.cfg ]; then
    source $1/patch.cfg
fi

# call makefile if there is one
if [ -f $1/makefile ]; then
    make -C $1
else
    make --eval="NAME=$1" --eval="ASFLAGS ?= --defsym .text=$TEXT" -f elf.mk
fi

# get ENTRY and ROMSIZE args from patch.cfg
PATCH_ARGS=
if [ ! -z ${ENTRY+x} ]; then PATCH_ARGS+="--entry=$ENTRY "; fi
PATCH_ARGS+="--pad $ROMSIZE "

# merge this elf's symbols list into the working list
nm $ELF_OUT > $BUILDDIR/sym.tmp
$TOOLS/mergesyms.py $SYMFILE_OUT $BUILDDIR/sym.tmp > $SYMFILE_OUT

# apply patches and fix CRC
$TOOLS/patch.py -vv $PATCH_ARGS $ROMFILE_OUT $ELF_OUT
$TOOLS/crc.py -v $ROMFILE_OUT

# update memory.ld for next patch
make_memory_ld $($TOOLS/patch.py --get-free $ROMFILE_OUT)
